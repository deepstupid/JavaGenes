//
// Copyright (C) 2005 United States Government as represented by the
// Administrator of the National Aeronautics and Space Administration
// (NASA).  All Rights Reserved.
// 
// This software is distributed under the NASA Open Source Agreement
// (NOSA), version 1.3.  The NOSA has been approved by the Open Source
// Initiative.  See the file NOSA.txt at the top of the distribution
// directory tree for the complete NOSA document.
// 
// THE SUBJECT SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY WARRANTY OF ANY
// KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT
// LIMITED TO, ANY WARRANTY THAT THE SUBJECT SOFTWARE WILL CONFORM TO
// SPECIFICATIONS, ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR
// A PARTICULAR PURPOSE, OR FREEDOM FROM INFRINGEMENT, ANY WARRANTY THAT
// THE SUBJECT SOFTWARE WILL BE ERROR FREE, OR ANY WARRANTY THAT
// DOCUMENTATION, IF PROVIDED, WILL CONFORM TO THE SUBJECT SOFTWARE.
//
//  Created by Al Globus on Mon Jul 08 2002.
package gov.nasa.javaGenes.EOSscheduling;

import gov.nasa.alsUtility.Error;
import gov.nasa.alsUtility.FieldRecordText;
import gov.nasa.alsUtility.Utility;

import java.util.Date;
import java.util.Vector;

// Files are generated by STK's AER capability
// STK puts out blank lines when a target never sees a sensor so STKAccessFile.java can deal with this.
public class STKAccessFile implements java.io.Serializable {
    protected Horizon horizon;
    protected FieldRecordText reader;
    protected int timeBetweenSamples;

    public STKAccessFile(String filename, int inTimeBetweenSamples) {
        timeBetweenSamples = inTimeBetweenSamples;
        Error.assertTrue(timeBetweenSamples > 0);

        // get horizon from first two lines
        reader = new FieldRecordText(filename);
        String line[] = reader.readLine();
        Error.assertTrue(line.length == 2);
        Error.assertTrue(line[0].equals("\"Start\""));
        Error.assertTrue(line[1].equals("\"Stop\""));
        line = reader.readLine();
        Error.assertTrue(line.length == 2);
        setHorizon(new Horizon(line[0], line[1]));
    }

    public int getCurrentLineNumber() {
        return reader.getCurrentLineNumber();
    }

    public String getFilename() {
        return reader.getFilename();
    }

    public Horizon getHorizon() {
        return horizon;
    }

    public void setHorizon(Horizon inHorizon) {
        Error.assertNotNull(inHorizon);
        if (horizon != null)
            Error.assertTrue(inHorizon.includes(horizon));
        horizon = inHorizon;
    }

    /**
     * @return the access windows for a task or null if no more tasks.
     */
    public AccessWindow[] readaTask() {
        // read header for horizon information
        String line[] = reader.readLine();
        if (line == null)
            return null;

        if (line.length == 4) {
            Error.assertTrue(line[0].equals("\"Time (UTCG)\""));
            Error.assertTrue(line[1].equals("\"Azimuth (deg)\""));
            Error.assertTrue(line[2].equals("\"Elevation (deg)\""));
            Error.assertTrue(line[3].equals("\"Range (km)\""));
        } else // no contact for this task
            return new AccessWindow[0];

        // get access windows including slewing information
        Vector accesses = new Vector();
        while (true) {
            line = reader.readLine();
            if (line == null)
                Error.fatal("No blank line at end of file "
                        + getFilename()
                        + " line "
                        + getCurrentLineNumber());
            if (line.length == 0)
                break;
            Error.assertTrue(line.length == 4);
            accesses.addElement(line);
        }
        if (accesses.size() < 2)
            return new AccessWindow[0];

        Vector windows = new Vector();
        AccessWindow w = new AccessWindow();
        String[] first = (String[]) accesses.elementAt(0);
        w.setStart(getTime(first));
        addPointingRequirement(w, getTime(first), first);
        for (int i = 1; i < accesses.size(); i++) {
            String[] current = (String[]) accesses.elementAt(i);
            String[] last = (String[]) accesses.elementAt(i - 1);
            int currentTime = getTime(current);
            int lastTime = getTime(last);
            if (currentTime - lastTime > timeBetweenSamples) {
                w.setEnd(lastTime);
                windows.addElement(w);
                w = new AccessWindow();
                w.setStart(currentTime);
            }
            addPointingRequirement(w, currentTime, current);
            if (i == accesses.size() - 1) {
                w.setEnd(currentTime);
                if (windows.size() == 0 || w != (AccessWindow) windows.lastElement())
                    windows.addElement(w);
                break;
            }
        }
        AccessWindow[] array = new AccessWindow[windows.size()];
        windows.copyInto(array);
        return array;
    }

    protected int getTime(String[] lineFromStkAccessFile) {
        String time = lineFromStkAccessFile[0];
        Date date = Utility.stkDateString2Date(time);
        return horizon.getIntegerTimeAt(date);
    }

    // NOTE: no unit test
    protected void addPointingRequirement(AccessWindow w, int time, String[] lineFromStkAccessFile) {
        double azimuth = Utility.string2double(lineFromStkAccessFile[1]);
        double elevation = Utility.string2double(lineFromStkAccessFile[2]);
        double range = Utility.string2double(lineFromStkAccessFile[3]);
        w.addPointingRequirement(new PointingRequirement(time, azimuth, elevation, range));
    }
}
